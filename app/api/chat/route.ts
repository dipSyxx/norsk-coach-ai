import { createHash } from "crypto";
import { generateText, streamText, Output } from "ai";
import { openai } from "@ai-sdk/openai";
import { getSession } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { buildSystemPrompt } from "@/lib/system-prompt";
import { extractionSchema } from "@/lib/extract-schema";
import { isExplanationIntent } from "@/lib/explanation-intent";
import { computeNextReviewAtFromStrength } from "@/lib/srs";
import {
  mergeVocabKinds,
  normalizeVocabKind,
  normalizeVocabSource,
} from "@/lib/vocab-taxonomy";
import { normalizeVocabTerm, prepareVocabTerm } from "@/lib/vocab-normalization";
import {
  decrypt,
  encrypt,
  isEncryptionReadyForRuntime,
} from "@/lib/encryption";
import { checkRateLimit } from "@/lib/rate-limit";
import { isContentSafe } from "@/lib/moderation";
import { chatRequestSchema, parseBodyWithSchema } from "@/lib/validation";
import type { PrismaClient } from "@prisma/client";

const MAX_INPUT_LENGTH = 4000;
const MAX_HISTORY_MESSAGES = 25;
const MAX_HISTORY_CHARS = 12_000;

const EXPLANATION_LANGUAGE_NAME: Record<string, string> = {
  norwegian: "Norwegian (bokmaal)",
  ukrainian: "Ukrainian",
  english: "English",
};

const MODE_LABELS: Record<string, string> = {
  free_chat: "Fri samtale",
  rollespill: "Rollespill",
  rett_teksten: "Rett teksten",
  ovelse: "Lag øvelse",
  grammatikk: "Grammatikk",
};

const EXPLANATION_LANG_INSTRUCTION: Record<string, string> = {
  ukrainian: "Give the explanation for each vocab item in Ukrainian.",
  english: "Give the explanation for each vocab item in English.",
  norwegian: "Give the explanation for each vocab item in simple Norwegian.",
};

const FALLBACK_BY_EXPLANATION_LANGUAGE: Record<string, string> = {
  norwegian:
    "Jeg kan ikke svare på det innholdet. La oss holde oss til norskøving. Prøv med et ord, en setning eller et grammatikkspørsmål.",
  ukrainian:
    "Я не можу відповісти на такий запит. Давай зосередимось на вивченні норвезької: напиши слово, речення або граматичне питання.",
  english:
    "I can't answer that request. Let's keep the chat focused on Norwegian learning. Try a word, sentence, or grammar question.",
};

const STOP_WORDS = new Set([
  "og",
  "eller",
  "i",
  "på",
  "til",
  "av",
  "for",
  "som",
  "det",
  "den",
  "de",
]);

function getLastUserMessageText(rawMessages: unknown): string {
  const list = Array.isArray(rawMessages)
    ? rawMessages
    : (rawMessages as { messages?: unknown[] })?.messages ?? [];

  for (let i = list.length - 1; i >= 0; i -= 1) {
    const candidate = list[i] as {
      role?: string;
      content?: string;
      parts?: Array<{ type?: string; text?: string }>;
    };

    if (candidate?.role !== "user") continue;

    const fromParts =
      candidate.parts
        ?.filter((part) => part?.type === "text" && typeof part.text === "string")
        .map((part) => part.text)
        .join("") ?? "";

    return (fromParts || candidate.content || "").trim();
  }

  return "";
}

function trimHistoryByApproxBudget(
  messages: Array<{ role: "user" | "assistant"; content: string }>
): Array<{ role: "user" | "assistant"; content: string }> {
  let total = 0;
  const selected: Array<{ role: "user" | "assistant"; content: string }> = [];

  for (let i = messages.length - 1; i >= 0; i -= 1) {
    const msg = messages[i];
    const size = msg.content.length;

    if (selected.length > 0 && total + size > MAX_HISTORY_CHARS) {
      break;
    }

    selected.push(msg);
    total += size;
  }

  return selected.reverse();
}

function safeFallbackText(explanationLanguage: string): string {
  return (
    FALLBACK_BY_EXPLANATION_LANGUAGE[explanationLanguage] ??
    FALLBACK_BY_EXPLANATION_LANGUAGE.norwegian
  );
}

function hashContent(content: string): string {
  return createHash("sha256").update(content).digest("hex").slice(0, 16);
}

function logAssistantModerationTelemetry(params: {
  userId: string;
  sessionId: string;
  status: "ok" | "blocked" | "outage";
  reasonCategory?: string | null;
  contentHash: string;
}) {
  console.info("assistant_moderation_telemetry", {
    userId: params.userId,
    sessionId: params.sessionId,
    assistantModerationStatus: params.status,
    blockedAt: params.status === "ok" ? null : new Date().toISOString(),
    reasonCategory: params.reasonCategory ?? null,
    contentHash: params.contentHash,
  });
}

function isAutoGeneratedTitle(title: string): boolean {
  if (!title || title.trim() === "") return true;
  if (title.trim() === "Ny samtale") return true;

  return Object.values(MODE_LABELS).some((label) =>
    title.startsWith(`${label}: `)
  );
}

function shouldGenerateAiTitle(sessionTitle: string, messageCount: number): boolean {
  return messageCount >= 3 && messageCount <= 5 && isAutoGeneratedTitle(sessionTitle);
}

function buildFallbackTitle(mode: string, topic: string | null, firstUserText: string): string {
  const modeLabel = MODE_LABELS[mode] ?? mode;
  const rest = topic?.trim() || firstUserText.trim().slice(0, 30) || "Samtale";
  return `${modeLabel}: ${rest}`.slice(0, 50);
}

function sanitizeTitle(raw: string | null | undefined): string | null {
  const normalized = (raw ?? "")
    .replace(/[\n\r\t]+/g, " ")
    .replace(/["'`]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  if (!normalized) return null;
  return normalized.slice(0, 50);
}

async function generateSessionTitle(params: {
  mode: string;
  topic: string | null;
  firstUserText: string;
  assistantText: string;
}): Promise<string | null> {
  const modeLabel = MODE_LABELS[params.mode] ?? params.mode;

  try {
    const { text } = await generateText({
      model: openai("gpt-4.1-mini"),
      prompt: `Create one short Norwegian Bokmål chat title (max 50 chars, no quotes).

Mode: ${modeLabel}
Topic: ${params.topic || "(none)"}
First user message: ${params.firstUserText || "(none)"}
Latest assistant answer: ${params.assistantText || "(none)"}

Return only the title.`,
      maxRetries: 1,
      temperature: 0.2,
    });

    return sanitizeTitle(text);
  } catch {
    return null;
  }
}

function normalizeFreeText(raw: string): string {
  return raw
    .normalize("NFKC")
    .toLocaleLowerCase("nb-NO")
    .replace(/\s+/g, " ")
    .trim();
}

function shouldKeepExtractedTerm(params: {
  rawTerm: string;
  assistantText: string;
  lastUserMessage: string;
}): boolean {
  const prepared = prepareVocabTerm(params.rawTerm);
  if (!prepared) return false;

  if (prepared.term !== "å" && prepared.term.length < 2) return false;
  if (!/\p{L}/u.test(prepared.term)) return false;

  const normalizedTerm = normalizeVocabTerm(prepared.term);
  if (STOP_WORDS.has(normalizedTerm)) return false;

  const assistantNormalized = normalizeFreeText(params.assistantText);
  if (!assistantNormalized.includes(normalizedTerm)) return false;

  const userNormalized = normalizeFreeText(params.lastUserMessage);
  if (userNormalized.includes(normalizedTerm) && !assistantNormalized.includes(normalizedTerm)) {
    return false;
  }

  return true;
}

export async function POST(req: Request) {
  try {
    if (!process.env.OPENAI_API_KEY) {
      return new Response("OPENAI_API_KEY is not set", { status: 500 });
    }

    const user = await getSession();
    if (!user) {
      return new Response("Unauthorized", { status: 401 });
    }

    if (!isEncryptionReadyForRuntime()) {
      return new Response(
        JSON.stringify({
          error: "Message encryption is not configured for this environment.",
          code: "ENCRYPTION_NOT_CONFIGURED",
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const rateLimit = checkRateLimit(user.id);
    if (!rateLimit.ok) {
      return new Response(
        JSON.stringify({
          error: "Too many messages. Please wait a moment before sending again.",
        }),
        {
          status: 429,
          headers: {
            "Content-Type": "application/json",
            "Retry-After": String(rateLimit.retryAfter ?? 60),
          },
        }
      );
    }

    const parsed = await parseBodyWithSchema(req, chatRequestSchema);
    if (!parsed.success) {
      return new Response(JSON.stringify(parsed.error), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const sessionId = parsed.data.sessionId;
    const userContent = getLastUserMessageText(parsed.data.messages);

    if (userContent.length > MAX_INPUT_LENGTH) {
      return new Response(
        JSON.stringify({
          error: `Message is too long. Please keep it under ${MAX_INPUT_LENGTH} characters.`,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    if (userContent) {
      const moderation = await isContentSafe(userContent);
      if (!moderation.safe) {
        if (moderation.reason === "OUTAGE") {
          return new Response(
            JSON.stringify({
              error:
                "Message screening is temporarily unavailable. Please try again shortly.",
              code: "MODERATION_UNAVAILABLE",
            }),
            { status: 503, headers: { "Content-Type": "application/json" } }
          );
        }

        return new Response(
          JSON.stringify({
            error:
              "Your message could not be sent. Please keep the conversation appropriate for a language learning context.",
          }),
          { status: 400, headers: { "Content-Type": "application/json" } }
        );
      }
    }

    const session = await prisma.chatSession.findFirst({
      where: { id: sessionId, userId: user.id },
    });
    if (!session) {
      return new Response("Session not found", { status: 404 });
    }

    const userContentForExtraction = userContent;
    if (userContent) {
      const { payload, keyVersion } = encrypt(userContent);
      await prisma.message.create({
        data: {
          sessionId,
          role: "user",
          content: payload,
          keyVersion,
        },
      });
    }

    const historyRows = await prisma.message.findMany({
      where: { sessionId },
      orderBy: { createdAt: "desc" },
      take: MAX_HISTORY_MESSAGES,
      select: { role: true, content: true, keyVersion: true },
    });

    const historyMessages = historyRows
      .reverse()
      .map((row) => ({
        role: row.role as "user" | "assistant",
        content: decrypt(row.content, row.keyVersion),
      }));

    const trimmedHistory = trimHistoryByApproxBudget(historyMessages);

    const baseSystemPrompt = buildSystemPrompt(user, {
      mode: session.mode,
      topic: session.topic ?? undefined,
    });

    const strictExplanationOverride = isExplanationIntent(userContent)
      ? `\n\nStrict instruction for this reply: the user is asking for meaning/translation/explanation. Write explanatory prose fully in ${EXPLANATION_LANGUAGE_NAME[user.explanation_language] ?? EXPLANATION_LANGUAGE_NAME.norwegian}. Keep explanatory text in one explanation language only.`
      : "";

    const systemPrompt = `${baseSystemPrompt}${strictExplanationOverride}`;

    const result = streamText({
      model: openai("gpt-4.1-mini"),
      system: systemPrompt,
      messages: trimmedHistory,
      maxRetries: 2,
      onFinish: async ({ text }) => {
        const generatedAssistantText = (text || "").trim();
        const finalText = generatedAssistantText || safeFallbackText(user.explanation_language);

        const assistantModeration = await isContentSafe(finalText);
        const moderationStatus: "ok" | "blocked" | "outage" = assistantModeration.safe
          ? "ok"
          : assistantModeration.reason === "OUTAGE"
            ? "outage"
            : "blocked";

        logAssistantModerationTelemetry({
          userId: user.id,
          sessionId,
          status: moderationStatus,
          reasonCategory: assistantModeration.categories?.[0] ?? assistantModeration.reason ?? null,
          contentHash: hashContent(finalText),
        });

        const assistantTextForPersistence =
          moderationStatus === "ok" ? finalText : safeFallbackText(user.explanation_language);

        const { payload: encryptedAssistant, keyVersion: assistantKeyVersion } = encrypt(assistantTextForPersistence);
        await prisma.message.create({
          data: {
            sessionId,
            role: "assistant",
            content: encryptedAssistant,
            keyVersion: assistantKeyVersion,
          },
        });

        const msgCount = await prisma.message.count({ where: { sessionId } });

        if (shouldGenerateAiTitle(session.title, msgCount)) {
          const firstUserRow = await prisma.message.findFirst({
            where: { sessionId, role: "user" },
            orderBy: { createdAt: "asc" },
            select: { content: true, keyVersion: true },
          });

          const firstUserText = firstUserRow
            ? decrypt(firstUserRow.content, firstUserRow.keyVersion)
            : "";

          const aiTitle = await generateSessionTitle({
            mode: session.mode,
            topic: session.topic,
            firstUserText,
            assistantText: assistantTextForPersistence,
          });

          const nextTitle =
            aiTitle ?? buildFallbackTitle(session.mode, session.topic, firstUserText);

          await prisma.chatSession.update({
            where: { id: sessionId },
            data: { title: nextTitle, updatedAt: new Date() },
          });
        } else {
          await prisma.chatSession.update({
            where: { id: sessionId },
            data: { updatedAt: new Date() },
          });
        }

        if (moderationStatus === "ok") {
          try {
            await extractVocabAndMistakes(
              user.id,
              sessionId,
              finalText,
              userContentForExtraction,
              user.explanation_language,
              prisma
            );
          } catch (err) {
            console.error("Extract vocab/mistakes failed (non-critical):", err);
          }
        }
      },
    });

    return result.toUIMessageStreamResponse();
  } catch (error) {
    console.error("Chat error:", error);
    return new Response("Internal server error", { status: 500 });
  }
}

async function extractVocabAndMistakes(
  userId: string,
  sessionId: string,
  assistantText: string,
  lastUserMessage: string,
  explanationLanguage: string,
  prismaClient: PrismaClient
) {
  const langInstruction =
    EXPLANATION_LANG_INSTRUCTION[explanationLanguage] ??
    EXPLANATION_LANG_INSTRUCTION.norwegian;

  const prompt = `You are analyzing a Norwegian tutor's reply to a student.

Last user message:
${lastUserMessage || "(none)"}

Assistant's reply:
${assistantText}

${langInstruction}

Extract:
1) Norwegian vocabulary, phrases, and grammar points that the tutor introduced, explained, used, highlighted, or corrected in this assistant reply.
   For each vocab item provide:
   - term: the Norwegian word or phrase
   - kind: one of vocab | phrase | grammar
   - source: one of assistant_reply | correction
   - explanation: brief meaning/explanation in the requested explanation language
   - example: a short Norwegian sentence that uses the term. If there is no suitable example, use empty string "".
2) Mistakes the tutor corrected (type, example: what the student wrote wrong, correction: the correct form).

Rules:
- Do NOT extract terms that appear only in the user's message unless the tutor also used or explained them in the assistant reply.
- Do NOT include filler/service words unless they are explicitly taught as grammar points.

Return empty arrays only if there is truly nothing to extract.`;

  const { output } = await generateText({
    model: openai("gpt-4.1-mini"),
    prompt,
    output: Output.object({
      schema: extractionSchema,
      name: "extraction",
      description: "Extracted vocabulary and mistake corrections",
    }),
    maxRetries: 1,
  });

  for (const v of output.vocab) {
    if (!v.term?.trim()) continue;
    if (
      !shouldKeepExtractedTerm({
        rawTerm: v.term,
        assistantText,
        lastUserMessage,
      })
    ) {
      continue;
    }

    const preparedTerm = prepareVocabTerm(v.term);
    if (!preparedTerm) continue;

    const normalizedKind = normalizeVocabKind(v.kind);
    const normalizedSource = normalizeVocabSource(v.source);

    const existingTerm = await prismaClient.vocabItem.findFirst({
      where: {
        userId,
        OR: [
          {
            term: {
              equals: preparedTerm.normalized,
              mode: "insensitive",
            },
          },
          {
            term: {
              equals: preparedTerm.rawTrimmed,
              mode: "insensitive",
            },
          },
        ],
      },
      select: { term: true, kind: true },
    });

    const mergedKind = mergeVocabKinds(existingTerm?.kind, normalizedKind);

    await prismaClient.vocabItem.upsert({
      where: {
        userId_term: {
          userId,
          term: existingTerm?.term ?? preparedTerm.term,
        },
      },
      create: {
        userId,
        sessionId,
        term: preparedTerm.term,
        kind: mergedKind,
        source: normalizedSource,
        explanation: v.explanation?.trim() ?? null,
        exampleSentence: v.example?.trim() ?? null,
        nextReviewAt: computeNextReviewAtFromStrength(0),
      },
      update: {
        kind: mergedKind,
        source: normalizedSource,
        explanation: v.explanation?.trim() ?? null,
        exampleSentence: v.example?.trim() ?? null,
        sessionId,
      },
    });
  }

  for (const m of output.mistakes) {
    if (!m.type?.trim()) continue;
    const mistakeType = m.type.trim();

    await prismaClient.mistakePattern.upsert({
      where: {
        userId_mistakeType: { userId, mistakeType },
      },
      create: {
        userId,
        sessionId,
        mistakeType,
        example: m.example?.trim() ?? null,
        correction: m.correction?.trim() ?? null,
      },
      update: {
        example: m.example?.trim() ?? null,
        correction: m.correction?.trim() ?? null,
        sessionId,
        count: { increment: 1 },
      },
    });
  }
}
